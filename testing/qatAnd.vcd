$date
	Sun Nov  8 11:06:48 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Testbench $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 " halt $end
$var wire 16 # instr [15:0] $end
$var wire 16 $ regfile_rdValue [15:0] $end
$var wire 1 % reset $end
$var wire 1 & shouldBrJmp $end
$var wire 16 ' sxi [15:0] $end
$var wire 16 ( ps1_regfile_rsValue_eff [15:0] $end
$var wire 16 ) ps1_regfile_rdValue_eff [15:0] $end
$var wire 16 * pc_eff [15:0] $end
$var wire 16 + brJmpTarget [15:0] $end
$var wire 16 , aluOut [15:0] $end
$var reg 16 - pc [15:0] $end
$var reg 1 . ps0_halt $end
$var reg 1 / ps2_bubble $end
$var reg 16 0 ps2_wbValue [15:0] $end
$var reg 1 1 psr01_halt $end
$var reg 16 2 psr01_ir [15:0] $end
$var reg 4 3 psr12_aluOp [3:0] $end
$var reg 16 4 psr12_branchTarget [15:0] $end
$var reg 1 5 psr12_brf $end
$var reg 1 6 psr12_brt $end
$var reg 1 7 psr12_halt $end
$var reg 1 8 psr12_jumpr $end
$var reg 1 9 psr12_memWrite $end
$var reg 4 : psr12_rdIndex [3:0] $end
$var reg 16 ; psr12_rdValue [15:0] $end
$var reg 4 < psr12_rsIndex [3:0] $end
$var reg 16 = psr12_rsValue [15:0] $end
$var reg 2 > psr12_wbSource [1:0] $end
$var reg 1 ? psr12_writeBack $end
$var reg 1 @ psr23_halt $end
$var reg 4 A psr23_wbIndex [3:0] $end
$var reg 16 B psr23_wbValue [15:0] $end
$var reg 1 C psr23_writeBack $end
$scope function is2WordFrmt $end
$var reg 16 D instr [15:0] $end
$var reg 1 E is2WordFrmt $end
$upscope $end
$scope function isBrf $end
$var reg 16 F instr [15:0] $end
$var reg 1 G isBrf $end
$upscope $end
$scope function isBrt $end
$var reg 16 H instr [15:0] $end
$var reg 1 I isBrt $end
$upscope $end
$scope function isCopy $end
$var reg 16 J instr [15:0] $end
$var reg 1 K isCopy $end
$upscope $end
$scope function isJumpr $end
$var reg 16 L instr [15:0] $end
$var reg 1 M isJumpr $end
$upscope $end
$scope function isLex $end
$var reg 16 N instr [15:0] $end
$var reg 1 O isLex $end
$upscope $end
$scope function isLhi $end
$var reg 16 P instr [15:0] $end
$var reg 1 Q isLhi $end
$upscope $end
$scope function isLoad $end
$var reg 16 R instr [15:0] $end
$var reg 1 S isLoad $end
$upscope $end
$scope function isStore $end
$var reg 16 T instr [15:0] $end
$var reg 1 U isStore $end
$upscope $end
$scope function isSysOrQat $end
$var reg 16 V instr [15:0] $end
$var reg 1 W isSysOrQat $end
$upscope $end
$scope function isWriteBack $end
$var reg 3 X f0Op [2:0] $end
$var reg 16 Y instr [15:0] $end
$var reg 1 Z isWriteBack $end
$upscope $end
$scope function usesALU $end
$var reg 16 [ instr [15:0] $end
$var reg 1 \ usesALU $end
$upscope $end
$scope module alu $end
$var wire 16 ] a [15:0] $end
$var wire 16 ^ b [15:0] $end
$var wire 4 _ op [3:0] $end
$var wire 16 ` i2fout [15:0] $end
$var wire 1 a fsltout $end
$var wire 16 b frecipout [15:0] $end
$var wire 16 c fnegout [15:0] $end
$var wire 16 d fmulout [15:0] $end
$var wire 16 e faddout [15:0] $end
$var wire 16 f f2iout [15:0] $end
$var reg 16 g out [15:0] $end
$scope module myf2i $end
$var wire 16 h f [15:0] $end
$var wire 16 i ui [15:0] $end
$var wire 1 j tiny $end
$var wire 16 k result [15:0] $end
$var wire 16 l i [15:0] $end
$var wire 1 m big $end
$scope module m0 $end
$var wire 16 n a [15:0] $end
$var wire 16 o b [15:0] $end
$var wire 1 p torf $end
$var wire 1 j result $end
$upscope $end
$scope module m1 $end
$var wire 16 q a [15:0] $end
$var wire 16 r b [15:0] $end
$var wire 1 s torf $end
$var wire 1 m result $end
$upscope $end
$upscope $end
$scope module myfadd $end
$var wire 16 t a [15:0] $end
$var wire 16 u b [15:0] $end
$var wire 1 v eqsgn $end
$var wire 8 w texp [7:0] $end
$var wire 8 x tbman [7:0] $end
$var wire 8 y taman [7:0] $end
$var wire 1 z ssign $end
$var wire 9 { sman [8:0] $end
$var wire 5 | slead [4:0] $end
$var wire 9 } sfrac [8:0] $end
$var wire 9 ~ sexp [8:0] $end
$var wire 16 !" s [15:0] $end
$var wire 16 "" result [15:0] $end
$var wire 16 #" r [15:0] $end
$var wire 1 $" amgt $end
$var wire 1 %" aegt $end
$scope module m0 $end
$var wire 16 &" s [15:0] $end
$var wire 5 '" t [4:0] $end
$var wire 8 (" s8 [7:0] $end
$var wire 4 )" s4 [3:0] $end
$var wire 2 *" s2 [1:0] $end
$var wire 5 +" d [4:0] $end
$upscope $end
$upscope $end
$scope module myfmul $end
$var wire 16 ," a [15:0] $end
$var wire 16 -" b [15:0] $end
$var wire 1 ." s $end
$var wire 16 /" result [15:0] $end
$var wire 16 0" r [15:0] $end
$var wire 16 1" m [15:0] $end
$var wire 8 2" e [7:0] $end
$upscope $end
$scope module myfneg $end
$var wire 16 3" f [15:0] $end
$var wire 16 4" result [15:0] $end
$upscope $end
$scope module myfrecip $end
$var wire 16 5" a [15:0] $end
$var wire 16 6" result [15:0] $end
$var wire 16 7" r [15:0] $end
$upscope $end
$scope module myfslt $end
$var wire 16 8" a [15:0] $end
$var wire 16 9" b [15:0] $end
$var wire 1 :" torf $end
$var wire 1 a result $end
$upscope $end
$scope module myi2f $end
$var wire 16 ;" i [15:0] $end
$var wire 16 <" pos [15:0] $end
$var wire 5 =" lead [4:0] $end
$var wire 16 >" f [15:0] $end
$scope module m0 $end
$var wire 16 ?" s [15:0] $end
$var wire 5 @" t [4:0] $end
$var wire 8 A" s8 [7:0] $end
$var wire 4 B" s4 [3:0] $end
$var wire 2 C" s2 [1:0] $end
$var wire 5 D" d [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx D"
bx C"
bx B"
bx A"
b0xxxx @"
bx ?"
bx >"
bx ="
bx <"
bx ;"
x:"
bx 9"
bx 8"
bx 7"
bx 6"
bx 5"
bx 4"
bx 3"
bx 2"
bx 1"
bx 0"
bx /"
x."
bx -"
bx ,"
bx +"
bx *"
bx )"
bx ("
b0xxxx '"
bx0000000 &"
x%"
x$"
bx #"
bx ""
bx !"
bx ~
bx }
bx |
bx {
xz
bx y
bx x
bx w
xv
bx u
bx t
xs
bx r
b100011011111111 q
xp
b1100011100000000 o
bx n
xm
bx l
bx k
xj
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
xa
bx `
bx _
bx ^
bx ]
x\
bx [
xZ
bx Y
bx X
xW
bx V
xU
bx T
xS
bx R
xQ
bx P
xO
bx N
xM
bx L
xK
bx J
xI
bx H
xG
bx F
xE
bx D
xC
bx B
bx A
x@
x?
bx >
bx =
bx <
bx ;
bx :
x9
x8
x7
x6
x5
bx 4
bx 3
bx 2
x1
bx 0
x/
x.
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
x&
0%
bx $
bx #
x"
0!
$end
#10
b1 ~
b100000000 }
b10 *"
b1000 )"
b0 C"
b10000000 ("
b0 '"
b0 B"
b0 f
b0 k
0j
b0 |
b0 +"
0a
b0 l
0m
0&
0p
b1000000000000000 &"
b100000000 {
b10000000 !"
b0 A"
b1111 @"
0:"
0s
0$"
b10000000 y
b0 d
b0 /"
b10000 ="
b10000 D"
b0 )
b0 (
b10000000 x
b10000001 2"
b0 i
b0 w
1v
0z
b0 e
b0 ""
0."
b0 0"
b1000000000000000 c
b1000000000000000 4"
b111111100000000 b
b111111100000000 6"
b1111111111111111 0
b110001000000000 #
b0 *
0"
0%"
b100000000000000 1"
b0 +
b0 #"
b111111100000000 7"
b0 <"
b0 ?"
b0 `
b0 >"
b1111111111111111 ,
b1111111111111111 g
b0 '
b0 $
b0 -
0.
1@
b0 B
b0 A
0C
17
08
06
05
b0 4
b0 >
0?
09
b0 3
b0 _
b0 =
b0 ^
b0 u
b0 -"
b0 9"
b0 ;
b0 ]
b0 h
b0 n
b0 r
b0 t
b0 ,"
b0 3"
b0 5"
b0 8"
b0 ;"
b0 <
b0 :
11
b0 2
1%
#20
0%
#30
1"
bx #
b10 *
b0 0
1.
b110001000000000 2
b10 -
b10 >
0/
1W
b110001000000000 V
1E
b110001000000000 D
0M
b0 L
0I
b0 H
0G
b0 F
0K
b0 J
0S
b0 R
0\
b0 [
0Z
b0 X
b0 Y
0U
b0 T
0Q
b0 P
0O
b0 N
1!
#40
0!
