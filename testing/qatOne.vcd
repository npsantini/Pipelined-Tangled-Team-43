$date
	Thu Dec  3 14:10:05 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Testbench $end
$scope module uut $end
$var wire 1 ! clk $end
$var wire 1 " halt $end
$var wire 16 # instr [15:0] $end
$var wire 16 $ regfile_rdValue [15:0] $end
$var wire 1 % reset $end
$var wire 1 & shouldBrJmp $end
$var wire 16 ' sxi [15:0] $end
$var wire 16 ( ps1_regfile_rsValue_eff [15:0] $end
$var wire 16 ) ps1_regfile_rdValue_eff [15:0] $end
$var wire 16 * pc_eff [15:0] $end
$var wire 16 + brJmpTarget [15:0] $end
$var wire 16 , aluOut [15:0] $end
$var reg 16 - pc [15:0] $end
$var reg 1 . ps0_halt $end
$var reg 1 / ps2_bubble $end
$var reg 16 0 ps2_wbValue [15:0] $end
$var reg 1 1 psr01_halt $end
$var reg 16 2 psr01_ir [15:0] $end
$var reg 4 3 psr12_aluOp [3:0] $end
$var reg 16 4 psr12_branchTarget [15:0] $end
$var reg 1 5 psr12_brf $end
$var reg 1 6 psr12_brt $end
$var reg 1 7 psr12_halt $end
$var reg 1 8 psr12_jumpr $end
$var reg 1 9 psr12_memWrite $end
$var reg 4 : psr12_rdIndex [3:0] $end
$var reg 16 ; psr12_rdValue [15:0] $end
$var reg 4 < psr12_rsIndex [3:0] $end
$var reg 16 = psr12_rsValue [15:0] $end
$var reg 2 > psr12_wbSource [1:0] $end
$var reg 1 ? psr12_writeBack $end
$var reg 1 @ psr23_halt $end
$var reg 4 A psr23_wbIndex [3:0] $end
$var reg 16 B psr23_wbValue [15:0] $end
$var reg 1 C psr23_writeBack $end
$scope function is2WordFrmt $end
$var reg 16 D instr [15:0] $end
$var reg 1 E is2WordFrmt $end
$upscope $end
$scope function isBrf $end
$var reg 16 F instr [15:0] $end
$var reg 1 G isBrf $end
$upscope $end
$scope function isBrt $end
$var reg 16 H instr [15:0] $end
$var reg 1 I isBrt $end
$upscope $end
$scope function isCopy $end
$var reg 16 J instr [15:0] $end
$var reg 1 K isCopy $end
$upscope $end
$scope function isJumpr $end
$var reg 16 L instr [15:0] $end
$var reg 1 M isJumpr $end
$upscope $end
$scope function isLex $end
$var reg 16 N instr [15:0] $end
$var reg 1 O isLex $end
$upscope $end
$scope function isLhi $end
$var reg 16 P instr [15:0] $end
$var reg 1 Q isLhi $end
$upscope $end
$scope function isLoad $end
$var reg 16 R instr [15:0] $end
$var reg 1 S isLoad $end
$upscope $end
$scope function isQat $end
$var reg 16 T instr [15:0] $end
$var reg 1 U isQat $end
$upscope $end
$scope function isStore $end
$var reg 16 V instr [15:0] $end
$var reg 1 W isStore $end
$upscope $end
$scope function isSys $end
$var reg 16 X instr [15:0] $end
$var reg 1 Y isSys $end
$upscope $end
$scope function isWriteBack $end
$var reg 3 Z f0Op [2:0] $end
$var reg 16 [ instr [15:0] $end
$var reg 1 \ isWriteBack $end
$upscope $end
$scope function usesALU $end
$var reg 16 ] instr [15:0] $end
$var reg 1 ^ usesALU $end
$upscope $end
$scope module alu $end
$var wire 16 _ a [15:0] $end
$var wire 16 ` b [15:0] $end
$var wire 4 a op [3:0] $end
$var wire 16 b i2fout [15:0] $end
$var wire 1 c fsltout $end
$var wire 16 d frecipout [15:0] $end
$var wire 16 e fnegout [15:0] $end
$var wire 16 f fmulout [15:0] $end
$var wire 16 g faddout [15:0] $end
$var wire 16 h f2iout [15:0] $end
$var reg 16 i out [15:0] $end
$scope module myf2i $end
$var wire 16 j f [15:0] $end
$var wire 16 k ui [15:0] $end
$var wire 1 l tiny $end
$var wire 16 m result [15:0] $end
$var wire 16 n i [15:0] $end
$var wire 1 o big $end
$scope module m0 $end
$var wire 16 p a [15:0] $end
$var wire 16 q b [15:0] $end
$var wire 1 r torf $end
$var wire 1 l result $end
$upscope $end
$scope module m1 $end
$var wire 16 s a [15:0] $end
$var wire 16 t b [15:0] $end
$var wire 1 u torf $end
$var wire 1 o result $end
$upscope $end
$upscope $end
$scope module myfadd $end
$var wire 16 v a [15:0] $end
$var wire 16 w b [15:0] $end
$var wire 1 x eqsgn $end
$var wire 8 y texp [7:0] $end
$var wire 8 z tbman [7:0] $end
$var wire 8 { taman [7:0] $end
$var wire 1 | ssign $end
$var wire 9 } sman [8:0] $end
$var wire 5 ~ slead [4:0] $end
$var wire 9 !" sfrac [8:0] $end
$var wire 9 "" sexp [8:0] $end
$var wire 16 #" s [15:0] $end
$var wire 16 $" result [15:0] $end
$var wire 16 %" r [15:0] $end
$var wire 1 &" amgt $end
$var wire 1 '" aegt $end
$scope module m0 $end
$var wire 16 (" s [15:0] $end
$var wire 5 )" t [4:0] $end
$var wire 8 *" s8 [7:0] $end
$var wire 4 +" s4 [3:0] $end
$var wire 2 ," s2 [1:0] $end
$var wire 5 -" d [4:0] $end
$upscope $end
$upscope $end
$scope module myfmul $end
$var wire 16 ." a [15:0] $end
$var wire 16 /" b [15:0] $end
$var wire 1 0" s $end
$var wire 16 1" result [15:0] $end
$var wire 16 2" r [15:0] $end
$var wire 16 3" m [15:0] $end
$var wire 8 4" e [7:0] $end
$upscope $end
$scope module myfneg $end
$var wire 16 5" f [15:0] $end
$var wire 16 6" result [15:0] $end
$upscope $end
$scope module myfrecip $end
$var wire 16 7" a [15:0] $end
$var wire 16 8" result [15:0] $end
$var wire 16 9" r [15:0] $end
$upscope $end
$scope module myfslt $end
$var wire 16 :" a [15:0] $end
$var wire 16 ;" b [15:0] $end
$var wire 1 <" torf $end
$var wire 1 c result $end
$upscope $end
$scope module myi2f $end
$var wire 16 =" i [15:0] $end
$var wire 16 >" pos [15:0] $end
$var wire 5 ?" lead [4:0] $end
$var wire 16 @" f [15:0] $end
$scope module m0 $end
$var wire 16 A" s [15:0] $end
$var wire 5 B" t [4:0] $end
$var wire 8 C" s8 [7:0] $end
$var wire 4 D" s4 [3:0] $end
$var wire 2 E" s2 [1:0] $end
$var wire 5 F" d [4:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx F"
bx E"
bx D"
bx C"
b0xxxx B"
bx A"
bx @"
bx ?"
bx >"
bx ="
x<"
bx ;"
bx :"
bx 9"
bx 8"
bx 7"
bx 6"
bx 5"
bx 4"
bx 3"
bx 2"
bx 1"
x0"
bx /"
bx ."
bx -"
bx ,"
bx +"
bx *"
b0xxxx )"
bx0000000 ("
x'"
x&"
bx %"
bx $"
bx #"
bx ""
bx !"
bx ~
bx }
x|
bx {
bx z
bx y
xx
bx w
bx v
xu
bx t
b100011011111111 s
xr
b1100011100000000 q
bx p
xo
bx n
bx m
xl
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
xc
bx b
bx a
bx `
bx _
x^
bx ]
x\
bx [
bx Z
xY
bx X
xW
bx V
xU
bx T
xS
bx R
xQ
bx P
xO
bx N
xM
bx L
xK
bx J
xI
bx H
xG
bx F
xE
bx D
xC
bx B
bx A
x@
x?
bx >
bx =
bx <
bx ;
bx :
x9
x8
x7
x6
x5
bx 4
bx 3
bx 2
x1
bx 0
x/
x.
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
x&
0%
bx $
bx #
x"
0!
$end
#10
b1 ""
b100000000 !"
b10 ,"
b1000 +"
b0 E"
b10000000 *"
b0 )"
b0 D"
b0 h
b0 m
0l
b0 ~
b0 -"
0c
b0 n
0o
0&
0r
b1000000000000000 ("
b100000000 }
b10000000 #"
b0 C"
b1111 B"
0<"
0u
0&"
b10000000 {
b0 f
b0 1"
b10000 ?"
b10000 F"
b0 )
b0 (
b10000000 z
b10000001 4"
b0 k
b0 y
1x
0|
b0 g
b0 $"
00"
b0 2"
b1000000000000000 e
b1000000000000000 6"
b111111100000000 d
b111111100000000 8"
b1111111111111111 0
b100000000001000 #
b0 *
0"
0'"
b100000000000000 3"
b0 +
b0 %"
b111111100000000 9"
b0 >"
b0 A"
b0 b
b0 @"
b1111111111111111 ,
b1111111111111111 i
b0 '
b0 $
b0 -
0.
1@
b0 B
b0 A
0C
17
08
06
05
b0 4
b0 >
0?
09
b0 3
b0 a
b0 =
b0 `
b0 w
b0 /"
b0 ;"
b0 ;
b0 _
b0 j
b0 p
b0 t
b0 v
b0 ."
b0 5"
b0 7"
b0 :"
b0 ="
b0 <
b0 :
11
b0 2
1%
#20
0%
#30
b1000 '
bx #
b1 *
b0 0
01
b100000000001000 2
b1 -
b10 >
0/
0Y
b100000000001000 X
0E
b100000000001000 D
0M
b0 L
0I
b0 H
0G
b0 F
0K
b0 J
0S
b0 R
0^
b0 ]
0\
b0 Z
b0 [
0W
b0 V
0Q
b0 P
0O
b0 N
1!
#40
0!
#50
bx )
bx (
b1001 +
x"
bx '
bx $
bx *
07
b1001 4
b1000 <
x.
x1
bx 2
bx -
b100000000001000 L
b100000000001000 H
b100000000001000 F
b100000000001000 J
b100000000001000 R
b100000000001000 ]
b100 Z
b100000000001000 [
b100000000001000 V
b100000000001000 P
b100000000001000 N
xY
bx X
xE
bx D
1!
#60
0!
